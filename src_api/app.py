# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QpMxBtAbRM2t5D-69EGKHFGMmLB2suFO
"""

#!pip install fastapi uvicorn python-multipart

from fastapi import FastAPI
import joblib
import pandas as pd

# Charger le modèle (assurez-vous que le chemin du modèle est correct)
model = joblib.load("Octroi_credit_classification_model.pkl")

# Initialiser FastAPI
app = FastAPI()

# Endpoint de base pour vérifier que l'API fonctionne
@app.get("/")
def read_root():
    return {"message": "API de classification de crédits"}

# Endpoint pour prédire le statut du prêt
@app.post("/predict/")
def predict(data: dict):
    try:
        # Afficher les données reçues pour déboguer
        print("Données reçues :", data)

        # Convertir les données en DataFrame
        df = pd.DataFrame([data])

        # Gérer les données manquantes
        df.fillna({
            'gender': 'Male',
            'married': 'No',
            'dependents': 0,
            'education': 'Graduate',
            'self_employed': 'No',
            'applicant_income': df['applicant_income'].mean(),
            'coapplicant_income': 0,
            'loan_amount': df['loan_amount'].mean(),
            'loan_amount_term': 360,
            'credit_history': 1,
            'property_area': 'Urban'
        }, inplace=True)

        # Renommer les colonnes pour qu'elles correspondent aux noms utilisés lors de l'entraînement du modèle
        df.rename(columns={
            'gender': 'Gender',
            'married': 'Married',
            'dependents': 'Dependents',
            'education': 'Education',
            'self_employed': 'Self_Employed',
            'applicant_income': 'ApplicantIncome',
            'coapplicant_income': 'CoapplicantIncome',
            'loan_amount': 'LoanAmount',
            'loan_amount_term': 'Loan_Amount_Term',
            'credit_history': 'Credit_History',
            'property_area': 'Property_Area'
        }, inplace=True)

        # Transformer les colonnes catégorielles
        df['Gender'] = df['Gender'].apply(lambda x: 1 if x == 'Male' else 0)
        df['Married'] = df['Married'].apply(lambda x: 1 if x == 'Yes' else 0)
        df['Self_Employed'] = df['Self_Employed'].apply(lambda x: 1 if x == 'Yes' else 0)
        df['Education'] = df['Education'].apply(lambda x: 1 if x == 'Graduate' else 0)
        df['Property_Area'] = df['Property_Area'].map({'Urban': 2, 'Semiurban': 1, 'Rural': 0})

        # Afficher le DataFrame pour déboguer
        print("DataFrame après transformation et gestion des valeurs manquantes :", df)

        # Faire une prédiction
        prediction = model.predict(df)

        # Retourner la prédiction
        return {"prediction": int(prediction[0])}
    
    except Exception as e:
        # Afficher toute erreur rencontrée
        print(f"Erreur : {e}")
        return {"error": str(e)}
